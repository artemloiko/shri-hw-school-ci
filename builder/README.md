# SHRI

# SHRI School CI Server

### Node.js version 12.16.1

## Getting started

```bash
cd $dir && npm ci #dirs = [server, agent]
```

Для разработки используется nodemon

```bash
npm run start # запуск сервиса
npm run dev # запуск сервиса в дев режиме
npm run dev:debug # запуск сервиса в дебаг режиме
```

Также используется eslint на уровне всего билдера для этого нужно в папке builder выполнить

```bash
npm i
npm run lint # запустить линтера для всего проекта билдера
```

Конфигурация билд-сервера

```js
// файл server/server-conf.json
{
    "port": 12345,
    "apiBaseUrl": "https://hw.shri.yandex/api/",
    "apiToken": "asdfgh"
}

// либо передать переменные окружения
PORT=12345
API_BASE_URL="https://hw.shri.yandex/api/"
API_TOKEN="asdfgh"
```

Конфигурация билд-агента

```js
// файл agent/agent-conf.json
{
    "port": 12345,
    "serverHost": "127.0.0.1",
    "serverPort": 8080
}

// либо передать переменные окружения
PORT=12345
SERVER_HOST="127.0.0.1"
SERVER_PORT=8080
```

## About

#вопрос Для того чтобы добиться независимости сервера и некоторые скрипты отчасти дублируются (config и logger). Как обычно в таких случаях поступают? Унифицировать их, вынести в корень и залинковать через package.json?

#### Сервер

Начал писать тесты, но осилил покрыть только buildServer :smiley:

Метод `POST /notify-build-result` - проксирует запрос в хранилище.  
Если в текущем списке агентов нет агента с agentId вернуть 403 ошибку.  
Тело запроса

```json
{
  "agentId": "string",
  "data": {
    "buildId": "string",
    "success": "boolean",
    "duration": "number",
    "buildLog": "string"
  }
}
```

Метод `POST /notify-agent` - сохраняет данные об агенте во внутренний список агентов.  
Из `body` вытаскиваем порт и из `request` его `hostname`.

Структура данных об агенте

```json
{
  "id": "string",
  "port": "number",
  "host": "string",
  "isBuilding": "boolean",
  "currentBuild": "object"
}
```

При регистрации агента дать ему айдишник, сохранить во внутренний список и вернуть агенту этот айдишник.
При успешном билде агент отправляет свой айдишник, чтобы по нему сбросить данные о текущем билда у агента.

## Вопросы

#### Сервер должен корректно обрабатывать ситуацию, когда агент прекратил работать между сборками.

Сервер периодически проходит цикл отправки билдов в агенты.
На очередной итерации цикла, если агент на ручке POST /build
возвращает ошибку мы оповещаем об этом, удаляем его из списка агентов и ищем следующего свободного агента.

#### Сервер должен корректно обрабатывать ситуацию, когда агент прекратил работать в процессе выполнения сборки.

Проверка агентов, каждый N минут ходить на ручку GET /build - статус 200 скипаем. Если получаем ошибку, то оповещаем о ней.  
Во внутренний список билдов добавляем в начало билд текущего агента.  
Агента удаляем из списка агентов.

При перезагрузке сервера, список прошлих агентов подгружается из сохраненного файла и он сразу же проходится по нему и проверяет все ли агенты на месте.

#### Агент должен корректно обрабатывать ситуацию, когда при старте не смог соединиться с сервером.

Оповещаем об ошибке что не можем стартануть из-за того что сервер не работает.
Т.к. у нас нет отдельной ручки с помощью которой можно привязать не вижу смысла стартовать его в холостую.

Можно было попробовать через таймаут периодически запрашивать сервер,
но это может длиться бесконечно и при этом он никакой работы полезной не сделает.

#### Агент должен корректно обрабатывать ситуацию, когда при отправке результатов сборки не смог соединиться с сервером.

Оповещаем об ошибке соединения с сервером. После чего делает shutdown.  
Я думал как вариант сохранять логи билда и отправлять их после следующего запуска,
но до следующего запуска этого агента сервер может восстановить работу
и отправить этот билд другому агенту который уже сбилдит и сохранит это.

Если при отправке логов ошибка 403 (его нет в списке агентов сервера),
сбрасывает свои результаты сборки и по новому делает /notify-agent
Я пробовал сохранять и отправлять эти результаты, но это в данном случае слишком тяжело синхронизировать.  
Поэтому просто по новой регистрируем агент, а сервер уже все разрулит.
